from registrations import send_apply_confirm
from db import db

from flask import Blueprint, request, Response, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from bson import ObjectId

import boto3
from werkzeug.utils import secure_filename

import pytz
import datetime
import requests

import io
from pdfminer.high_level import extract_text


resume_api = Blueprint('resumes', __name__)

ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx'}
BUCKET = 'hophacks-resume'
DEEPSEEK_API_KEY = "sk-23fc33eec2c844f4ac342142170afa12"
API_URL = "https://api.deepseek.com/v1/chat/completions"

# remove weird directories just in case
def check_filename(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@resume_api.route('/', methods = ['POST'])
@jwt_required
def upload():
    """Upload a resume to the current users profile. Behind the scene stores a file in AWS s3.

    :reqheader Authorization: ``Bearer <JWT Token>``

    :form file: Resume file, should be .pdf or .docx

    :status 200: File uploaded successfully
    :status 400: No file was uploaded, or wrong file type
    :status 422: Not logged in

    """
    if 'file' not in request.files:
        return jsonify({"msg": "No file"}), 400
    file = request.files['file']

    if file.filename == '':
        return jsonify({"msg": "No selected file"}), 400

    file_name = secure_filename(file.filename)
    if not (file and check_filename(file.filename)):
        return jsonify({"msg": "Incorrect file type"}), 400

    s3 = boto3.client('s3')
    # Get user
    id = get_jwt_identity()
    user = db.users.find_one({'_id': ObjectId(id)})

    # remove old resume
    try :
        if ('resume' in user):
            if (user['resume'] == ""):
                eastern = pytz.timezone("America/New_York")
                eventFile = open("event.txt", "r")
                result = db.users.update_many(
                {
                    '_id': ObjectId(id),
                    'registrations.event' : eventFile.read()
                },
                {
                    '$set': {
                        "registrations.$.apply": True,
                        "registrations.$.apply_at": datetime.datetime.utcnow(),
                        "registrations.$.status": "applied"
                    }
                }
            )
                send_apply_confirm(user['username'], user['profile']['first_name'])
            else:
                old_file_name = user['resume']
                object_name = 'Fall-2024/{}-{}'.format(id, old_file_name)
                s3.delete_object(Bucket=BUCKET, Key=object_name)
    except Exception as e:
        print(e)
        return jsonify({'msg': str(e)}, 400)
        

    # TODO make this atomic? what if the file upload doesn't work?
    object_name = 'Fall-2024/{}-{}'.format(id, file_name)
    s3.upload_fileobj(file, BUCKET, object_name)

    db.users.update_one(
        {'_id': ObjectId(id)},
        {'$set': {'resume': file_name}}
    )

    return jsonify({'msg': 'file uploaded'}, 200)


@resume_api.route('/filename', methods = ['GET'])
@jwt_required
def filename():
    """Get the filename of the current user's resume.

    :reqheader Authorization: ``Bearer <JWT Token>``

    Example Response JSON:
    .. sourcecode:: json

        {
            "filename": "ElaineWong.pdf",
        }


    :resjson filename: name of resume file

    :status 200: File uploaded successfully
    :status 422: Not logged in

    """

    id = get_jwt_identity()
    user = db.users.find_one({'_id': ObjectId(id)})

    if ('resume' not in user):
        return jsonify({'filename': ''}), 200

    return jsonify({'filename': user['resume']}), 200


def get_resume_url():
    """Get the resume URL for the current user.

    :reqheader Authorization
    :resjson url: URL of the resume file
    """
    id = get_jwt_identity()
    user = db.users.find_one({'_id': ObjectId(id)})

    if ('resume' not in user):
        return jsonify({'msg': 'no resume uploaded!'}, 404)

    s3 = boto3.client('s3')
    object_name = 'Fall-2024/{}-{}'.format(id, user['resume'])

    url = s3.generate_presigned_url('get_object',
                                     Params={'Bucket': BUCKET, 'Key': object_name},
                                     ExpiresIn=600)
    return url, None, 200

@resume_api.route('/', methods = ['GET'])
@jwt_required
def download():
    """Get the actual resume file stored in S3. (though actually returns a link).

    :reqheader Authorization: ``Bearer <JWT Token>``

    :resjson url: temporary link generated by S3 where user can download file from
    :status 200: File uploaded successfully
    :status 422: Not logged in

    """
    url = get_resume_url()
    return jsonify({'url': url})

def url_to_pdf(url: str) -> bytes:
    """Convert the resume URL to a PDF file.

    :reqheader Authorization
    :resjson url: URL of the resume file
    """
    response = requests.get(url)
    response.raise_for_status()
    return response.content

def pdf_to_text(file_bytes: bytes) -> str:
    """Convert the PDF file to text.

    :reqheader Authorization
    :resjson text: Text extracted from the PDF file
    """
    with io.BytesIO(file_bytes) as file:
        text = extract_text(file)
    return text

def summarize_resume(resume_text: str) -> str:
    headers = {
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
        "Content-Type": "application/json"
    }

    messages = [
        {"role": "system", "content": (
                "You're a witty and friendly assistant helping hackers introduce themselves at Hopkins's hackathon. "
                "Your job is to write exactly one short, casual, and fun sentence based on each hacker’s resume. "
                "The sentence should help others decide if they'd want to team up with this person. "
                "Keep it under 25 words, avoid listing everything — just one punchy line that gives off good vibes. "
                "NEVER write more than one sentence. NEVER include multiple options. NEVER explain anything."
            )},
        {"role": "user", "content": (
                "Here's a resume from a hacker who's participating in Hopkins's hackathon. "
                "Write exactly one casual, fun one-liner that they'll show on their profile to help others form teams. "
                "Highlight one or two of their most interesting traits or skills (like ML, full-stack, math, or vibes). "
                "DO NOT write multiple lines, paragraphs, or bonus options.\n\n"
                f"{resume_text}"
            )}
    ]

    payload = {
        "model": "deepseek-chat",
        "messages": messages,
        "temperature": 0.9,  # more creative
        "top_p": 1.0
    }

    response = requests.post(API_URL, json=payload, headers=headers)
    response.raise_for_status()
    return response.json()["choices"][0]["message"]["content"]

@resume_api.route('/summarize', methods = ['GET'])
@jwt_required
def summarize():
    """Summarize the resume of the current user.

    :reqheader Authorization
    """
    print("DEBUG: Successfully called summarize endpoint")
    url, _, _ = get_resume_url()
    print("DEBUG: Successfully got resume URL")
    file_bytes = url_to_pdf(url)
    print("DEBUG: Successfully converted URL to PDF")
    text = pdf_to_text(file_bytes)
    print("DEBUG: Successfully converted PDF to text")
    summary = summarize_resume(text)
    print("DEBUG: Successfully summarized resume")
    return jsonify({'summary': summary}), 200